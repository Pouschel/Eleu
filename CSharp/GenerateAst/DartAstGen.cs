namespace GenerateAst
{
	class DartAstGen
	{
		public static void Run(string outputDir)
		{


			//> call-define-ast
			DefineAst(outputDir, "Expr", new string[] {
	//> Statements and State assign-expr
	"Assign   : String Name, Expr Value",
	//< Statements and State assign-expr
	"Binary   : Expr Left, Token Op, Expr Right",
	//> Functions call-expr
	"Call     : Expr Callee, String? Method, bool CallSuper, List<Expr> Arguments",
	//< Functions call-expr
	//> Classes get-ast
	"Get      : Expr Obj, String Name",
	//< Classes get-ast
	"Grouping : Expr Expression",
	"Literal  : Object? Value",
	//> Control Flow logical-ast
	"Logical  : Expr Left, Token Op, Expr Right",
	//< Control Flow logical-ast
	//> Classes set-ast
	"Set      : Expr Obj, String Name, Expr Value",
	//< Classes set-ast
	//> Inheritance super-expr
	"Super    : String Keyword, String Method",
	//< Inheritance super-expr
	//> Classes this-ast
	"This     : String Keyword",
	//< Classes this-ast
	/* Representing Code call-define-ast < Statements and State var-expr
        "Unary    : Token operator, Expr right"
  */
	//> Statements and State var-expr
	"Unary    : Token Op, Expr Right",
	"Variable : String Name" }
			//< Statements and State var-expr
			);
			//> Statements and State stmt-ast

			DefineAst(outputDir, "Stmt", new string[] {
	"Block      : List<Stmt> Statements",
	"Class      : String Name, VariableExpr? Superclass," +
							" List<FunctionStmt> Methods",
	"Expression : Expr expression",
	"Function   : FunctionType Type, String Name, List<Token> Paras," +
							" List<Stmt> Body",
	"If         : Expr Condition, Stmt ThenBranch," +
							" Stmt? ElseBranch",
	"Assert			: Expr expression, String? message, bool isErrorAssert",
	"Return     : Token Keyword, Expr? Value",
	"BreakContinue: bool IsBreak",
	"Var        : String Name, Expr? Initializer",
	"While      : Expr Condition, Stmt Body, Expr? Increment",
	"Repeat     : Expr Count, Stmt Body"	 ,
}
			);
		}
		static void DefineAst(string outputDir, string baseName, string[] types)
		{
			string path = outputDir + "/ast_" + baseName.ToLower() + ".dart";
			if (File.Exists(path))
				new FileInfo(path).IsReadOnly = false;
			var writer = File.CreateText(path);

			//> omit
			writer.println("// This file was generated by a tool. Do not edit!");
			writer.println("// AST classes for " + baseName.ToLower());
			writer.WriteLine("// ignore_for_file: prefer_initializing_formals");
			writer.println("import '../scanning.dart';");
			writer.println("import 'ast_parser.dart';");
			if (baseName == "Stmt")
			{
				writer.println("import 'ast_expr.dart';");
				writer.println("import '../eleu.dart';");
			}

			writer.println();
			defineVisitor(writer, baseName, types);

			//< omit
			writer.println();

			// base Expr stmt class
			writer.println("abstract class " + baseName + " extends ExprStmtBase {");
			writer.println($"  R Accept<R>({baseName}Visitor<R> visitor);");
			writer.println();

			foreach (string type in types)
			{
				string className = type.Split(":")[0].Trim();
				var fieldList = type.Split(":")[1].Trim();
				var fields = fieldList.Split(", "); // [robust]

				writer.Write($"  static {className}{baseName} {className}({fieldList}) => {className}{baseName}(");
				for (int i = 0; i < fields.Length; i++)
				{
					if (i > 0) writer.Write(", ");
					string field = fields[i];
					string name = field.Split(" ")[1];
					writer.Write(name);
				}
				writer.println(");");
			}
			writer.println("}");
			writer.println();

			writer.println("  // Nested " + baseName + " classes here...");

			//> nested-classes
			// The AST classes.
			foreach (string type in types)
			{
				string className = type.Split(":")[0].Trim();
				string fields = type.Split(":")[1].Trim(); // [robust]
				defineType(writer, baseName, className, fields);
			}

			//< omit
			writer.Close();
			new FileInfo(path).IsReadOnly = true;
		}
		//< define-ast
		//> define-visitor
		static void defineVisitor(TextWriter writer, string baseName, string[] types)
		{
			writer.println($"abstract class {baseName}Visitor<R> {{");

			foreach (string type in types)
			{
				string typeName = type.Split(":")[0].Trim();
				writer.println("    R Visit" + typeName + baseName + "(" +
						typeName + baseName + " " + baseName.ToLower() + ");");
			}
			writer.println("  }");

		}

		static void defineType(TextWriter writer, string baseName, string className, string fieldList)
		{
			writer.println("  // " + baseName.ToLower() + "-" + className.ToLower());
			writer.println($"  class {className}{baseName} extends {baseName} {{");

			//> omit
			// Hack. Stmt.Class has such a long constructor that it overflows
			// the line length on the Appendix II page. Wrap it.
			if (fieldList.Length > 64)
				fieldList = fieldList.Replace(", ", ",\n          ");
			var fieldList1 = fieldList.Replace(",\n          ", ", ");
			//< omit

			// Store parameters in fields.
			string[] fields = fieldList1.Split(", ");
			foreach (string field in fields)
			{
				writer.println("    late " + field + ";");
			}
			writer.println();


			//< omit
			// Constructor.
			writer.println("    " + className + baseName + "(" + fieldList + ") {");

			//> omit
			foreach (string field in fields)
			{
				string name = field.Split(" ")[1];
				writer.println("      this." + name + " = " + name + ";");
			}

			writer.println("    }");
			//> accept-method

			// Visitor pattern.
			writer.println();
			writer.println("    @override");
			writer.println($"    R Accept<R>({baseName}Visitor<R> visitor) {{");
			writer.println("      return visitor.Visit" +
					className + baseName + "(this);");
			writer.println("    }");
			//< accept-method
			writer.println("  }");
			//writer.println("//< " +	baseName.ToLower() + "-" + className.ToLower());
		}
	}
}