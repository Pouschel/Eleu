using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


class TsAstGen
{
	public static void Run(string outputDir)
	{


		//> call-define-ast
		DefineAst(outputDir, "Expr", new string[] {
	//> Statements and State assign-expr
	"Assign   : string Name, Expr Value",
	//< Statements and State assign-expr
	"Binary   : Expr Left, Token Op, Expr Right",
	//> Functions call-expr
	"Call     : Expr Callee, string | null Method, boolean CallSuper, Expr[] Arguments",
	//< Functions call-expr
	//> Classes get-ast
	"Get      : Expr Obj, string Name",
	//< Classes get-ast
	"Grouping : Expr Expression",
	"Literal  : any Value",
	//> Control Flow logical-ast
	"Logical  : Expr Left, Token Op, Expr Right",
	//< Control Flow logical-ast
	//> Classes set-ast
	"Set      : Expr Obj, string Name, Expr Value",
	//< Classes set-ast
	//> Inheritance super-expr
	"Super    : string Keyword, string Method",
	//< Inheritance super-expr
	//> Classes this-ast
	"This     : string Keyword",
	//< Classes this-ast
	/* Representing Code call-define-ast < Statements and State var-expr
        "Unary    : Token operator, Expr right"
  */
	//> Statements and State var-expr
	"Unary    : Token Op, Expr Right",
	"Variable : string Name"
	}
	//	//< Statements and State var-expr
		);

		//return;

		DefineAst(outputDir, "Stmt", new string[] {
	"Block      : Stmt[] Statements",
	"Class      : string Name, ExprVariable Superclass," +
							" StmtFunction[] Methods",
	"Expression : Expr expression",
	"Function   : FunctionType Type, string Name, Token[] Paras," +
							" Stmt[] Body",
	"If         : Expr Condition, Stmt ThenBranch," +
							" Stmt ElseBranch",
	"Assert			: Expr expression, string message, boolean isErrorAssert",
	"Return     : Token Keyword, Expr Value",
	"BreakContinue: boolean IsBreak",
	"Var        : string Name, Expr Initializer",
	"While      : Expr Condition, Stmt Body, Expr Increment",
	"Repeat     : Expr Count, Stmt Body"
}
		);
	}
	static void DefineAst(string outputDir, string baseName, string[] types)
	{
		string path = outputDir + "/" + baseName + ".ts";
		if (File.Exists(path))
			new FileInfo(path).IsReadOnly = false;
		var writer = File.CreateText(path);
		writer.println("/// <reference path=\"ExprStmtBase.ts\"/>");
		writer.println("/// <reference path=\"..\\Globals.ts\"/>");
		if (baseName=="Stmt")
			writer.println("/// <reference path=\"Expr.ts\"/>");
		writer.println("// This file was generated by a tool. Do not edit!");
		writer.println("// AST classes for " + baseName.ToLower());
		writer.println("namespace Eleu {");
		defineVisitor(writer, baseName, types);


		writer.println();
		writer.println("export abstract class " + baseName + " extends ExprStmtBase {");

		
		writer.println("");
		writer.println();
		writer.println($"  abstract Accept<R>(visitor: {baseName}Visitor<R>): R;");
		writer.println("}");

		writer.println();
		writer.println("  // Nested " + baseName + " classes here...");
		//< omit
		//> nested-classes
		// The AST classes.
		foreach (string type in types)
		{
			string className = type.Split(":")[0].Trim();
			string fields = type.Split(":")[1].Trim(); // [robust]
			defineType(writer, baseName, className, fields);
		}
		writer.println("}");
		writer.Close();
		new FileInfo(path).IsReadOnly = true;
	}

	static void defineVisitor(TextWriter writer, string baseName, string[] types)
	{
		writer.println($" export interface {baseName}Visitor<R> {{");

		foreach (string type in types)
		{
			string typeName = type.Split(":")[0].Trim();
			writer.println($"    Visit{typeName}{baseName}({baseName.ToLower()}: {baseName}{typeName}): R;");
//			writer.println("    R Visit" + typeName + baseName + "(" +					typeName + " " + baseName.ToLower() + ");");
		}
		writer.println("  }");
	}

	static void defineType(TextWriter writer, string baseName, string className, string fieldList)
	{
		writer.println("  // " + baseName.ToLower() + "-" + className.ToLower());
		writer.println($"  export class {baseName}{className} extends {baseName} {{");
		//> omit
		// Hack. Stmt.Class has such a long constructor that it overflows
		// the line length on the Appendix II page. Wrap it.
		if (fieldList.Length > 64)
		{
			fieldList = fieldList.Replace(", ", ",\n          ");
		}
		var fieldList1 = fieldList.Replace(",\n          ", ", ");
		//< omit

		// Store parameters in fields.
		string[] fields = fieldList1.Split(", ");
		string argList = "";
		foreach (string field in fields)
		{
			var parts = field.Split(' ', StringSplitOptions.RemoveEmptyEntries);
			var tname = string.Join(" ", parts,0,parts.Length-1);
			var el = $"{parts[^1]}: {tname}";
			if (argList.Length > 0) argList += ", ";
			argList += el;
			writer.println($"    {el};");
		}
		writer.println();

		// Constructor.
		writer.println("    constructor"  + "(" + argList + ") {");
		writer.println("      super();");
		//> omit
		foreach (string field in fields)
		{
			string name = field.Split(" ")[^1];
			writer.println("      this." + name + " = " + name + ";");
		}

		writer.println("    }");

		// Visitor pattern.
		writer.println();
		writer.println($"     Accept<R>(visitor: {baseName}Visitor<R>): R {{");
		writer.println("      return visitor.Visit" +	className + baseName + "(this);");
		writer.println("    }");
		writer.println("  }");
	}
}
